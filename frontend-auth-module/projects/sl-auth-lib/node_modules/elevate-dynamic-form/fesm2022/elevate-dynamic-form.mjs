import * as i0 from '@angular/core';
import { Component, Inject, Input, ViewChild, NgModule, NO_ERRORS_SCHEMA } from '@angular/core';
import * as i1 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormControl, FormArray, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';
import * as i2$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import * as i4 from '@angular/material/form-field';
import { MatFormFieldModule } from '@angular/material/form-field';
import * as i5 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i6$2 from '@angular/material/select';
import { MatSelectModule } from '@angular/material/select';
import * as i7 from '@angular/material/core';
import * as i6$1 from '@angular/material/slide-toggle';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import * as i9 from '@angular/material/slider';
import { MatSliderModule } from '@angular/material/slider';
import * as i6 from '@angular/material/dialog';
import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import * as i4$1 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i5$1 from '@angular/material/chips';
import { MatChipsModule } from '@angular/material/chips';
import { Subject } from 'rxjs';
import * as i3 from '@angular/material/radio';
import { MatRadioModule } from '@angular/material/radio';
import * as i3$1 from '@angular/material/checkbox';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatDatepickerModule } from '@angular/material/datepicker';

class DynamicFormComponent {
    constructor() { }
    ngOnInit() { }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DynamicFormComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: DynamicFormComponent, selector: "lib-dynamic-form", ngImport: i0, template: ` <p>dynamic-form works!</p> `, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DynamicFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-dynamic-form', template: ` <p>dynamic-form works!</p> ` }]
        }], ctorParameters: () => [] });

class DialogInputComponent {
    constructor(dialogData) {
        this.dialogData = dialogData;
    }
    ngOnInit() { }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DialogInputComponent, deps: [{ token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: DialogInputComponent, selector: "lib-dialog-input", ngImport: i0, template: "<div class=\"dialog-header\">\n  <mat-label mat-dialog-title>{{ dialogData?.header }}</mat-label>\n  <mat-icon class=\"mat-cancel-icon\" [mat-dialog-close]=\"false\"\n    >cancel_circle_outline</mat-icon\n  >\n</div>\n<div mat-dialog-content>\n  <mat-form-field style=\"width: 100%\" floatLabel=\"always\">\n    <mat-label>{{ dialogData?.label }}</mat-label>\n    <input\n      matInput\n      [(ngModel)]=\"data\"\n      [required]=\"dialogData?.required\"\n      [maxlength]=\"dialogData?.maxLength\"\n    />\n  </mat-form-field>\n</div>\n<div mat-dialog-actions class=\"buttons-section\">\n  <button mat-raised-button [mat-dialog-close]=\"false\">\n    {{ dialogData?.buttonText?.cancel }}\n  </button>\n  <button mat-raised-button [mat-dialog-close]=\"data\" cdkFocusInitial>\n    {{ dialogData?.buttonText?.ok }}\n  </button>\n</div>\n", styles: [".dialog-header{display:flex;flex-direction:row;justify-content:space-between}.buttons-section{justify-content:end}\n"], dependencies: [{ kind: "directive", type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i1.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { kind: "directive", type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i2.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i4.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i4.MatLabel, selector: "mat-label" }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i6.MatDialogClose, selector: "[mat-dialog-close], [matDialogClose]", inputs: ["aria-label", "type", "mat-dialog-close", "matDialogClose"], exportAs: ["matDialogClose"] }, { kind: "directive", type: i6.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i6.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i6.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DialogInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-dialog-input', template: "<div class=\"dialog-header\">\n  <mat-label mat-dialog-title>{{ dialogData?.header }}</mat-label>\n  <mat-icon class=\"mat-cancel-icon\" [mat-dialog-close]=\"false\"\n    >cancel_circle_outline</mat-icon\n  >\n</div>\n<div mat-dialog-content>\n  <mat-form-field style=\"width: 100%\" floatLabel=\"always\">\n    <mat-label>{{ dialogData?.label }}</mat-label>\n    <input\n      matInput\n      [(ngModel)]=\"data\"\n      [required]=\"dialogData?.required\"\n      [maxlength]=\"dialogData?.maxLength\"\n    />\n  </mat-form-field>\n</div>\n<div mat-dialog-actions class=\"buttons-section\">\n  <button mat-raised-button [mat-dialog-close]=\"false\">\n    {{ dialogData?.buttonText?.cancel }}\n  </button>\n  <button mat-raised-button [mat-dialog-close]=\"data\" cdkFocusInitial>\n    {{ dialogData?.buttonText?.ok }}\n  </button>\n</div>\n", styles: [".dialog-header{display:flex;flex-direction:row;justify-content:space-between}.buttons-section{justify-content:end}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }] });

class ChipInputComponent {
    constructor(diaglog) {
        this.diaglog = diaglog;
        this.enableSelectAll = false;
        this.touched = false;
        this.onChange = (value) => { };
        this.onTouched = () => { };
    }
    ngOnInit() { }
    writeValue(value) {
        this.selectedChips = new Set();
        this.chipControl.options.map((chipItem) => {
            if (value) {
                value.forEach((val) => {
                    if (val.value == chipItem.value) {
                        this.selectedChips.add(chipItem);
                    }
                });
            }
        });
        if (this.selectedChips.size === this.chipControl.options.length) {
            this.enableSelectAll = true;
        }
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    markAsTouched() {
        if (!this.touched) {
            this.onTouched();
            this.touched = true;
        }
    }
    onChipClick(chip) {
        this.markAsTouched();
        if (this.selectedChips.has(chip)) {
            this.selectedChips.delete(chip);
        }
        else {
            this.selectedChips.add(chip);
        }
        if (this.selectedChips.size) {
            this.onChange([...this.selectedChips]);
        }
        else {
            this.onChange([]);
        }
        this.enableSelectAll =
            this.selectedChips.size == this.chipControl.options.length;
    }
    addOption() {
        const dialogRef = this.diaglog.open(DialogInputComponent, {
            data: {
                header: this.chipControl.meta.addNewPopupHeader,
                label: this.chipControl.meta.addNewPopupSubHeader,
                required: true,
                maxLength: 20,
                buttonText: {
                    ok: 'Add',
                    cancel: 'Cancel',
                },
            },
            width: '450px',
        });
        dialogRef.afterClosed().subscribe((data) => {
            if (data && data !== '') {
                let newOption = {
                    label: data,
                    value: data,
                };
                this.chipControl.options.push(newOption);
                this.onChipClick(newOption);
            }
        });
    }
    toggleSelectAll() {
        this.markAsTouched();
        if (this.enableSelectAll) {
            this.chipControl.options.map((chipItem) => {
                this.selectedChips.add(chipItem);
            });
        }
        else {
            this.selectedChips.clear();
        }
        if (this.selectedChips.size) {
            this.onChange([...this.selectedChips]);
        }
        else {
            this.onChange([]);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ChipInputComponent, deps: [{ token: i6.MatDialog }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: ChipInputComponent, selector: "lib-chip-input", inputs: { chipControl: "chipControl" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: ChipInputComponent,
                multi: true,
            },
        ], ngImport: i0, template: "<mat-chip-listbox\n  #chipList\n  [multiple]=\"chipControl?.multiple\"\n  [required]=\"chipControl?.validators?.required\"\n  style=\"margin-top: 10px\"\n>\n  <div class=\"chip-options-list\">\n    <mat-chip-option\n      *ngFor=\"let chip of chipControl?.options\"\n      [value]=\"chip.value\"\n      (click)=\"onChipClick(chip)\"\n      [selected]=\"this.selectedChips.has(chip)\"\n    >\n      <div>{{ chip?.label }}</div>\n      <mat-icon\n        matChipRemove\n        *ngIf=\"this.selectedChips.has(chip)\"\n        (click)=\"onChipClick(chip)\"\n      >\n        cancel\n      </mat-icon>\n    </mat-chip-option>\n    <mat-chip\n      *ngIf=\"chipControl?.meta?.showAddOption\"\n      (click)=\"addOption()\"\n      style=\"cursor: pointer\"\n    >\n      <mat-icon>add_circle</mat-icon> Add\n    </mat-chip>\n  </div>\n  <mat-slide-toggle\n    *ngIf=\"chipControl?.meta?.showSelectAll\"\n    [(ngModel)]=\"enableSelectAll\"\n    (change)=\"toggleSelectAll()\"\n  ></mat-slide-toggle>\n</mat-chip-listbox>\n", styles: [".chip-options-list{display:flex;flex-direction:row;flex:1;flex-wrap:wrap}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5$1.MatChip, selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]", inputs: ["role", "id", "aria-label", "aria-description", "value", "color", "removable", "highlighted", "disableRipple", "disabled", "tabIndex"], outputs: ["removed", "destroyed"], exportAs: ["matChip"] }, { kind: "component", type: i5$1.MatChipListbox, selector: "mat-chip-listbox", inputs: ["multiple", "aria-orientation", "selectable", "compareWith", "required", "hideSingleSelectionIndicator", "value"], outputs: ["change"] }, { kind: "component", type: i5$1.MatChipOption, selector: "mat-basic-chip-option, [mat-basic-chip-option], mat-chip-option, [mat-chip-option]", inputs: ["selectable", "selected"], outputs: ["selectionChange"] }, { kind: "directive", type: i5$1.MatChipRemove, selector: "[matChipRemove]" }, { kind: "component", type: i6$1.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["name", "id", "labelPosition", "aria-label", "aria-labelledby", "aria-describedby", "required", "color", "disabled", "disableRipple", "tabIndex", "checked", "hideIcon"], outputs: ["change", "toggleChange"], exportAs: ["matSlideToggle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ChipInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-chip-input', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: ChipInputComponent,
                            multi: true,
                        },
                    ], template: "<mat-chip-listbox\n  #chipList\n  [multiple]=\"chipControl?.multiple\"\n  [required]=\"chipControl?.validators?.required\"\n  style=\"margin-top: 10px\"\n>\n  <div class=\"chip-options-list\">\n    <mat-chip-option\n      *ngFor=\"let chip of chipControl?.options\"\n      [value]=\"chip.value\"\n      (click)=\"onChipClick(chip)\"\n      [selected]=\"this.selectedChips.has(chip)\"\n    >\n      <div>{{ chip?.label }}</div>\n      <mat-icon\n        matChipRemove\n        *ngIf=\"this.selectedChips.has(chip)\"\n        (click)=\"onChipClick(chip)\"\n      >\n        cancel\n      </mat-icon>\n    </mat-chip-option>\n    <mat-chip\n      *ngIf=\"chipControl?.meta?.showAddOption\"\n      (click)=\"addOption()\"\n      style=\"cursor: pointer\"\n    >\n      <mat-icon>add_circle</mat-icon> Add\n    </mat-chip>\n  </div>\n  <mat-slide-toggle\n    *ngIf=\"chipControl?.meta?.showSelectAll\"\n    [(ngModel)]=\"enableSelectAll\"\n    (change)=\"toggleSelectAll()\"\n  ></mat-slide-toggle>\n</mat-chip-listbox>\n", styles: [".chip-options-list{display:flex;flex-direction:row;flex:1;flex-wrap:wrap}\n"] }]
        }], ctorParameters: () => [{ type: i6.MatDialog }], propDecorators: { chipControl: [{
                type: Input
            }] } });

class RadioInputComponent {
    constructor(fb) {
        this.fb = fb;
        this.touched = false;
        this.stateChanges = new Subject();
        this.onChange = (value) => { };
        this.onTouched = () => { };
        this.form = this.fb.group({});
    }
    ngOnInit() {
        this.form.addControl(this.radioControl.name, new FormControl(this.radioControl.value || null));
        this.form.get(this.radioControl.name)?.valueChanges.subscribe((value) => {
            this.onChange(value);
            this.stateChanges.next();
        });
    }
    writeValue(value) {
        this.selectedValue = '';
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    markAsTouched() {
        if (!this.touched) {
            this.onTouched();
            this.touched = true;
        }
    }
    ngOnDestroy() {
        this.stateChanges.complete();
    }
    onRadioChange(event) {
        this.markAsTouched();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: RadioInputComponent, deps: [{ token: i1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: RadioInputComponent, selector: "lib-radio-input", inputs: { radioControl: "radioControl" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: RadioInputComponent,
                multi: true,
            },
        ], ngImport: i0, template: "<div [formGroup]=\"form\" style=\"margin-top: 10px\">\n  <mat-radio-group\n    [value]=\"radioControl?.value\"\n    [formControlName]=\"radioControl?.name\"\n    [required]=\"radioControl?.validators?.required\"\n    (change)=\"onRadioChange($event)\"\n    class=\"radio-options-list\"\n  >\n    <mat-radio-button\n      *ngFor=\"let option of radioControl?.options\"\n      [value]=\"option.value\"\n      style=\"margin-bottom: 10px\"\n      >{{ option?.label }}</mat-radio-button\n    >\n  </mat-radio-group>\n</div>\n", styles: [".radio-options-list{display:flex;flex-direction:column}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: i3.MatRadioGroup, selector: "mat-radio-group", inputs: ["color", "name", "labelPosition", "value", "selected", "disabled", "required"], outputs: ["change"], exportAs: ["matRadioGroup"] }, { kind: "component", type: i3.MatRadioButton, selector: "mat-radio-button", inputs: ["id", "name", "aria-label", "aria-labelledby", "aria-describedby", "disableRipple", "tabIndex", "checked", "value", "labelPosition", "disabled", "required", "color"], outputs: ["change"], exportAs: ["matRadioButton"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: RadioInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-radio-input', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RadioInputComponent,
                            multi: true,
                        },
                    ], template: "<div [formGroup]=\"form\" style=\"margin-top: 10px\">\n  <mat-radio-group\n    [value]=\"radioControl?.value\"\n    [formControlName]=\"radioControl?.name\"\n    [required]=\"radioControl?.validators?.required\"\n    (change)=\"onRadioChange($event)\"\n    class=\"radio-options-list\"\n  >\n    <mat-radio-button\n      *ngFor=\"let option of radioControl?.options\"\n      [value]=\"option.value\"\n      style=\"margin-bottom: 10px\"\n      >{{ option?.label }}</mat-radio-button\n    >\n  </mat-radio-group>\n</div>\n", styles: [".radio-options-list{display:flex;flex-direction:column}\n"] }]
        }], ctorParameters: () => [{ type: i1.FormBuilder }], propDecorators: { radioControl: [{
                type: Input
            }] } });

class CheckboxInputComponent {
    constructor(fb) {
        this.fb = fb;
        this.touched = false;
        this.form = this.fb.group({});
        this.stateChanges = new Subject();
        this.onChange = (value) => { };
        this.onTouched = () => { };
    }
    ngOnInit() {
        let value = this.checkboxControl.value;
        let optionsControl = this.checkboxControl.options.map((data) => {
            if (value &&
                value.find((val) => {
                    return val.label == data.label;
                })) {
                return new FormControl(data);
            }
            else {
                return new FormControl('');
            }
        });
        this.form.addControl(this.checkboxControl.name, new FormArray(optionsControl));
        this.form
            .get(this.checkboxControl.name)
            ?.valueChanges.subscribe((value) => {
            let selectedValues = value.filter((val) => {
                return val;
            });
            if (!selectedValues.length) {
                this.onChange('');
            }
            else {
                this.onChange(selectedValues);
            }
            this.stateChanges.next();
        });
    }
    writeValue(value) {
        this.selectedOptions = '';
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    markAsTouched() {
        if (!this.touched) {
            this.onTouched();
            this.touched = true;
        }
    }
    onCheckboxChange(event, option, index) {
        let currentControl = this.form.get(this.checkboxControl.name);
        if (event.checked) {
            currentControl.controls[index].patchValue(option);
        }
        else {
            currentControl.controls[index].patchValue('');
        }
        this.markAsTouched();
    }
    ngOnDestroy() {
        this.stateChanges.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: CheckboxInputComponent, deps: [{ token: i1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: CheckboxInputComponent, selector: "lib-checkbox-input", inputs: { checkboxControl: "checkboxControl" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: CheckboxInputComponent,
                multi: true,
            },
        ], ngImport: i0, template: "<div [formGroup]=\"form\" style=\"margin-top: 10px\">\n  <div\n    *ngFor=\"let option of checkboxControl?.options; let idx = index\"\n    [formArrayName]=\"checkboxControl?.name\"\n  >\n    <mat-checkbox\n      [formControlName]=\"idx\"\n      [value]=\"option.value\"\n      (change)=\"onCheckboxChange($event, option, idx)\"\n    >\n      {{ option?.label }}\n    </mat-checkbox>\n  </div>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: i1.FormArrayName, selector: "[formArrayName]", inputs: ["formArrayName"] }, { kind: "component", type: i3$1.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: CheckboxInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-checkbox-input', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: CheckboxInputComponent,
                            multi: true,
                        },
                    ], template: "<div [formGroup]=\"form\" style=\"margin-top: 10px\">\n  <div\n    *ngFor=\"let option of checkboxControl?.options; let idx = index\"\n    [formArrayName]=\"checkboxControl?.name\"\n  >\n    <mat-checkbox\n      [formControlName]=\"idx\"\n      [value]=\"option.value\"\n      (change)=\"onCheckboxChange($event, option, idx)\"\n    >\n      {{ option?.label }}\n    </mat-checkbox>\n  </div>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i1.FormBuilder }], propDecorators: { checkboxControl: [{
                type: Input
            }] } });

class StarRatingComponent {
    constructor() {
        this.rating = 0;
        this.touched = false;
        this.onChange = (change) => { };
        this.onTouched = () => { };
    }
    ngOnInit() {
        this.ratingList = [];
        for (let i = 0; i < this.starsCount; i++) {
            this.ratingList.push(i);
        }
    }
    writeValue(value) {
        this.rating = value;
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    markAsTouched() {
        if (!this.touched) {
            this.onTouched();
            this.touched = true;
        }
    }
    onRatingChange(rate) {
        this.markAsTouched();
        this.rating = rate + 1;
        this.onChange(this.rating);
    }
    displayIcons(idx) {
        return this.rating && this.rating >= idx + 1 ? 'star' : 'star_border';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: StarRatingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: StarRatingComponent, selector: "lib-star-rating", inputs: { starsCount: "starsCount", label: "label" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                multi: true,
                useExisting: StarRatingComponent,
            },
        ], ngImport: i0, template: "<div class=\"rating-list\">\n  <div *ngFor=\"let star of ratingList; let idx = index\">\n    <mat-icon class=\"rating-icon\" (click)=\"onRatingChange(idx)\">{{\n      displayIcons(idx)\n    }}</mat-icon>\n  </div>\n</div>\n", styles: [".rating-list{display:flex;flex-direction:row;margin-top:10px}.rating-icon{font-size:30px;margin-right:10px;color:gold;cursor:pointer}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: StarRatingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-star-rating', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            multi: true,
                            useExisting: StarRatingComponent,
                        },
                    ], template: "<div class=\"rating-list\">\n  <div *ngFor=\"let star of ratingList; let idx = index\">\n    <mat-icon class=\"rating-icon\" (click)=\"onRatingChange(idx)\">{{\n      displayIcons(idx)\n    }}</mat-icon>\n  </div>\n</div>\n", styles: [".rating-list{display:flex;flex-direction:row;margin-top:10px}.rating-icon{font-size:30px;margin-right:10px;color:gold;cursor:pointer}\n"] }]
        }], ctorParameters: () => [], propDecorators: { starsCount: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

// const CUSTOM_DATE_FORMATS: NgxMatDateFormats = {
//   parse: {
//     dateInput: 'DD/MM/YYYY',
//   },
//   display: {
//     dateInput: 'LL LT',
//     monthYearLabel: 'MMM YYYY',
//     dateA11yLabel: 'LL',
//     monthYearA11yLabel: 'MMM YYYY',
//   },
// };
class MainFormComponent {
    constructor(fb) {
        this.fb = fb;
        this.myForm = this.fb.group({});
        this.showSpinners = true;
        this.showSeconds = false;
        this.touchUi = false;
        this.enableMeridian = true;
        this.stepHour = 1;
        this.stepMinute = 1;
        this.stepSecond = 1;
        this.color = 'warn';
        this.currentDate = new Date();
        this.maxDate = new Date(this.currentDate.getFullYear() + 10, this.currentDate.getMonth(), this.currentDate.getDate());
        this.dependedChildDate = '';
    }
    ngOnInit() {
        this.createForm(this.formJson);
    }
    createForm(controls) {
        for (const control of controls) {
            const validatorsToAdd = [];
            for (const [key, value] of Object.entries(control.validators)) {
                switch (key) {
                    case 'min':
                        validatorsToAdd.push(Validators.min(value));
                        break;
                    case 'max':
                        validatorsToAdd.push(Validators.max(value));
                        break;
                    case 'required':
                        if (value) {
                            validatorsToAdd.push(Validators.required);
                        }
                        break;
                    case 'requiredTrue':
                        if (value) {
                            validatorsToAdd.push(Validators.requiredTrue);
                        }
                        break;
                    case 'email':
                        if (value) {
                            validatorsToAdd.push(Validators.email);
                        }
                        break;
                    case 'minLength':
                        validatorsToAdd.push(Validators.minLength(value));
                        break;
                    case 'maxLength':
                        validatorsToAdd.push(Validators.maxLength(value));
                        break;
                    case 'pattern':
                        validatorsToAdd.push(Validators.pattern(value));
                        break;
                    case 'nullValidator':
                        if (value) {
                            validatorsToAdd.push(Validators.nullValidator);
                        }
                        break;
                    default:
                        break;
                }
            }
            this.myForm.addControl(control.name, this.fb.control({ value: control.value, disabled: control.disabled || false }, validatorsToAdd));
        }
    }
    dateSelected(event, control) {
        const indexToEdit = this.formJson.findIndex((formControl) => formControl.name === control.name);
        if (indexToEdit !== -1) {
            this.formJson[indexToEdit].value = event.value;
        }
        if (control.dependedChild) {
            this.dependedChild = control.dependedChild;
            this.dependedChildDate = event.value;
        }
        else {
            this.dependedParent = control.dependedParent;
            this.dependedParentDate = event.value;
        }
    }
    // dateInputClick(control: any, datetimePicker: NgxMatDatetimepicker<any>) {
    //   if (this.myForm.get(control.name)?.value)
    //     datetimePicker._applyPendingSelection = this.myForm.get(control.name)?.value;
    //   datetimePicker.open();
    // }
    togglePasswordVisibility(control) {
        control.type = control.type === 'password' ? 'text' : 'password';
        control.showPasswordIcon = true;
    }
    compareWith(value1, value2) {
        return JSON.stringify(value1.value) == JSON.stringify(value2);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MainFormComponent, deps: [{ token: i1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: MainFormComponent, selector: "dynamic-form", inputs: { formJson: "formJson" }, viewQueries: [{ propertyName: "picker", first: true, predicate: ["picker"], descendants: true }], ngImport: i0, template: "<div>\n  <form [formGroup]=\"myForm\">\n    <div *ngFor=\"let control of formJson\">\n      <mat-form-field\n        *ngIf=\"control?.type === 'text' || control?.type === 'password'\"\n        floatLabel=\"always\"\n      >\n        <mat-label>{{ control?.label }}</mat-label>\n        <input\n          matInput\n          [placeholder]=\"control?.placeHolder\"\n          [type]=\"control?.type\"\n          [formControlName]=\"control?.name\"\n          [maxlength]=\"control?.validators.maxLength\"\n          [required]=\"control?.validators?.required\"\n          style=\"margin-top: 10px\"\n        />\n        <mat-icon\n          matSuffix\n          *ngIf=\"control?.type === 'password' || control?.showPasswordIcon\"\n          (click)=\"togglePasswordVisibility(control)\"\n          style=\"cursor: pointer\"\n        >\n          {{ control?.type === \"password\" ? \"visibility_off\" : \"visibility\" }}\n        </mat-icon>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'textarea'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <textarea\n          matInput\n          [formControlName]=\"control?.name\"\n          [placeholder]=\"control?.placeHolder\"\n          [maxlength]=\"control?.validators?.maxLength\"\n          [required]=\"control?.validators?.required\"\n          style=\"margin-top: 10px\"\n        >\n        </textarea>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'select'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <mat-select\n          [value]=\"control?.value\"\n          [formControlName]=\"control?.name\"\n          [required]=\"control?.validators?.required\"\n          [compareWith]=\"compareWith\"\n        >\n          <mat-option *ngFor=\"let option of control?.options\" [value]=\"option\">\n            {{ option.label }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'chip'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <lib-chip-input\n          [chipControl]=\"control\"\n          [formControlName]=\"control?.name\"\n        ></lib-chip-input>\n        <textarea\n          matInput\n          [formControlName]=\"control?.name\"\n          hidden\n          [required]=\"control?.validators?.required\"\n        ></textarea>\n      </mat-form-field>\n\n      <!-- <mat-form-field\n        *ngIf=\"control.type === 'date'\"\n        floatLabel=\"always\"\n        appearance=\"fill\"\n      >\n        <mat-label>{{ control?.label }}</mat-label>\n        <input\n          matInput\n          [ngxMatDatetimePicker]=\"picker\"\n          [formControlName]=\"control.name\"\n          [value]=\"control.value\"\n          [min]=\"\n            control.name === dependedChild ? dependedChildDate : currentDate\n          \"\n          [max]=\"maxDate\"\n          (dateChange)=\"dateSelected($event, control)\"\n          (click)=\"dateInputClick(control, picker)\"\n        />\n        <mat-datepicker-toggle matSuffix [for]=\"$any(picker)\">\n        </mat-datepicker-toggle>\n        <ngx-mat-datetime-picker\n          #picker\n          [showSpinners]=\"showSpinners\"\n          [showSeconds]=\"showSeconds\"\n          [stepHour]=\"stepHour\"\n          [stepMinute]=\"stepMinute\"\n          [stepSecond]=\"stepSecond\"\n          [touchUi]=\"touchUi\"\n          [enableMeridian]=\"enableMeridian\"\n        >\n        </ngx-mat-datetime-picker>\n      </mat-form-field> -->\n\n      <mat-form-field *ngIf=\"control?.type === 'range'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <mat-slider\n          style=\"width: 100%\"\n          [min]=\"control?.min\"\n          [max]=\"control?.max\"\n          [step]=\"control?.step\"\n          [discrete]=\"control?.showThumbLabel\"\n        >\n        <input matSliderThumb [formControlName]=\"control?.name\" [value]=\"control?.value\">\n        </mat-slider>\n        <textarea matInput [formControlName]=\"control?.name\" hidden></textarea>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'rating'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <lib-star-rating\n          [formControlName]=\"control.name\"\n          [label]=\"control.label\"\n          [starsCount]=\"control.noOfstars\"\n        ></lib-star-rating>\n        <textarea matInput [formControlName]=\"control?.name\" hidden></textarea>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'checkbox'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <input matInput [formControlName]=\"control?.name\" hidden />\n        <lib-checkbox-input\n          [checkboxControl]=\"control\"\n          [formControlName]=\"control?.name\"\n        ></lib-checkbox-input>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'radio'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <input matInput [formControlName]=\"control?.name\" hidden />\n        <lib-radio-input\n          [radioControl]=\"control\"\n          [formControlName]=\"control?.name\"\n        ></lib-radio-input>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type == 'toggle'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <mat-slide-toggle\n          [formControlName]=\"control?.name\"\n          [checked]=\"control?.value\"\n          [required]=\"control?.validators?.required\"\n          style=\"margin-top: 10px\"\n        >\n        </mat-slide-toggle>\n        <textarea\n          matInput\n          [formControlName]=\"control?.name\"\n          hidden\n          [required]=\"control?.validators?.required\"\n        ></textarea>\n      </mat-form-field>\n\n      <mat-error\n        *ngIf=\"\n          myForm.get(control?.name)?.touched &&\n          myForm.get(control?.name)?.invalid\n        \"\n      >\n        <div\n          class=\"error-message\"\n          *ngIf=\"\n            control?.errorMessage[\n              ((myForm.get(control.name)?.errors | keyvalue) || [])[0].key\n            ];\n            else genericErrorMessage\n          \"\n        >\n          <mat-icon class=\"error-icon\" matPrefix>error_outline</mat-icon>\n          {{\n            control?.errorMessage[\n              ((myForm.get(control.name)?.errors | keyvalue) || [])[0].key\n            ]\n          }}\n        </div>\n        <ng-template #genericErrorMessage>\n          <div class=\"error-message\">\n            <mat-icon class=\"error-icon\" matPrefix>error_outline</mat-icon>\n            Enter {{ control?.label }}\n          </div>\n        </ng-template>\n      </mat-error>\n    </div>\n  </form>\n</div>\n", styles: ["mat-form-field{width:100%}.error-message{display:flex;flex-direction:row;font-size:12px;margin-top:-10px}.error-icon{font-size:16px;width:20px;height:auto}::ng-deep .mat-form-field-appearance-fill .mat-form-field-flex{background-color:#fff}mat-label{font-size:20px;margin-bottom:10px}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f;background-color:#fff;color:#000000de}.mat-calendar-body-selected{background-color:#007f51;color:#fff}.mat-calendar-body-cell-content{border:none!important}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:#fff!important}.mdc-text-field--filled{background-color:#fff!important}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i1.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { kind: "directive", type: i1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: i2.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i4.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i4.MatLabel, selector: "mat-label" }, { kind: "directive", type: i4.MatError, selector: "mat-error, [matError]", inputs: ["id"] }, { kind: "directive", type: i4.MatPrefix, selector: "[matPrefix], [matIconPrefix], [matTextPrefix]", inputs: ["matTextPrefix"] }, { kind: "directive", type: i4.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i6$2.MatSelect, selector: "mat-select", inputs: ["aria-describedby", "panelClass", "disabled", "disableRipple", "tabIndex", "hideSingleSelectionIndicator", "placeholder", "required", "multiple", "disableOptionCentering", "compareWith", "value", "aria-label", "aria-labelledby", "errorStateMatcher", "typeaheadDebounceInterval", "sortComparator", "id", "panelWidth"], outputs: ["openedChange", "opened", "closed", "selectionChange", "valueChange"], exportAs: ["matSelect"] }, { kind: "component", type: i7.MatOption, selector: "mat-option", inputs: ["value", "id", "disabled"], outputs: ["onSelectionChange"], exportAs: ["matOption"] }, { kind: "component", type: i6$1.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["name", "id", "labelPosition", "aria-label", "aria-labelledby", "aria-describedby", "required", "color", "disabled", "disableRipple", "tabIndex", "checked", "hideIcon"], outputs: ["change", "toggleChange"], exportAs: ["matSlideToggle"] }, { kind: "component", type: i9.MatSlider, selector: "mat-slider", inputs: ["disabled", "discrete", "showTickMarks", "min", "color", "disableRipple", "max", "step", "displayWith"], exportAs: ["matSlider"] }, { kind: "directive", type: i9.MatSliderThumb, selector: "input[matSliderThumb]", inputs: ["value"], outputs: ["valueChange", "dragStart", "dragEnd"], exportAs: ["matSliderThumb"] }, { kind: "component", type: ChipInputComponent, selector: "lib-chip-input", inputs: ["chipControl"] }, { kind: "component", type: RadioInputComponent, selector: "lib-radio-input", inputs: ["radioControl"] }, { kind: "component", type: CheckboxInputComponent, selector: "lib-checkbox-input", inputs: ["checkboxControl"] }, { kind: "component", type: StarRatingComponent, selector: "lib-star-rating", inputs: ["starsCount", "label"] }, { kind: "pipe", type: i2$1.KeyValuePipe, name: "keyvalue" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MainFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'dynamic-form', template: "<div>\n  <form [formGroup]=\"myForm\">\n    <div *ngFor=\"let control of formJson\">\n      <mat-form-field\n        *ngIf=\"control?.type === 'text' || control?.type === 'password'\"\n        floatLabel=\"always\"\n      >\n        <mat-label>{{ control?.label }}</mat-label>\n        <input\n          matInput\n          [placeholder]=\"control?.placeHolder\"\n          [type]=\"control?.type\"\n          [formControlName]=\"control?.name\"\n          [maxlength]=\"control?.validators.maxLength\"\n          [required]=\"control?.validators?.required\"\n          style=\"margin-top: 10px\"\n        />\n        <mat-icon\n          matSuffix\n          *ngIf=\"control?.type === 'password' || control?.showPasswordIcon\"\n          (click)=\"togglePasswordVisibility(control)\"\n          style=\"cursor: pointer\"\n        >\n          {{ control?.type === \"password\" ? \"visibility_off\" : \"visibility\" }}\n        </mat-icon>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'textarea'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <textarea\n          matInput\n          [formControlName]=\"control?.name\"\n          [placeholder]=\"control?.placeHolder\"\n          [maxlength]=\"control?.validators?.maxLength\"\n          [required]=\"control?.validators?.required\"\n          style=\"margin-top: 10px\"\n        >\n        </textarea>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'select'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <mat-select\n          [value]=\"control?.value\"\n          [formControlName]=\"control?.name\"\n          [required]=\"control?.validators?.required\"\n          [compareWith]=\"compareWith\"\n        >\n          <mat-option *ngFor=\"let option of control?.options\" [value]=\"option\">\n            {{ option.label }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'chip'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <lib-chip-input\n          [chipControl]=\"control\"\n          [formControlName]=\"control?.name\"\n        ></lib-chip-input>\n        <textarea\n          matInput\n          [formControlName]=\"control?.name\"\n          hidden\n          [required]=\"control?.validators?.required\"\n        ></textarea>\n      </mat-form-field>\n\n      <!-- <mat-form-field\n        *ngIf=\"control.type === 'date'\"\n        floatLabel=\"always\"\n        appearance=\"fill\"\n      >\n        <mat-label>{{ control?.label }}</mat-label>\n        <input\n          matInput\n          [ngxMatDatetimePicker]=\"picker\"\n          [formControlName]=\"control.name\"\n          [value]=\"control.value\"\n          [min]=\"\n            control.name === dependedChild ? dependedChildDate : currentDate\n          \"\n          [max]=\"maxDate\"\n          (dateChange)=\"dateSelected($event, control)\"\n          (click)=\"dateInputClick(control, picker)\"\n        />\n        <mat-datepicker-toggle matSuffix [for]=\"$any(picker)\">\n        </mat-datepicker-toggle>\n        <ngx-mat-datetime-picker\n          #picker\n          [showSpinners]=\"showSpinners\"\n          [showSeconds]=\"showSeconds\"\n          [stepHour]=\"stepHour\"\n          [stepMinute]=\"stepMinute\"\n          [stepSecond]=\"stepSecond\"\n          [touchUi]=\"touchUi\"\n          [enableMeridian]=\"enableMeridian\"\n        >\n        </ngx-mat-datetime-picker>\n      </mat-form-field> -->\n\n      <mat-form-field *ngIf=\"control?.type === 'range'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <mat-slider\n          style=\"width: 100%\"\n          [min]=\"control?.min\"\n          [max]=\"control?.max\"\n          [step]=\"control?.step\"\n          [discrete]=\"control?.showThumbLabel\"\n        >\n        <input matSliderThumb [formControlName]=\"control?.name\" [value]=\"control?.value\">\n        </mat-slider>\n        <textarea matInput [formControlName]=\"control?.name\" hidden></textarea>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'rating'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <lib-star-rating\n          [formControlName]=\"control.name\"\n          [label]=\"control.label\"\n          [starsCount]=\"control.noOfstars\"\n        ></lib-star-rating>\n        <textarea matInput [formControlName]=\"control?.name\" hidden></textarea>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'checkbox'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <input matInput [formControlName]=\"control?.name\" hidden />\n        <lib-checkbox-input\n          [checkboxControl]=\"control\"\n          [formControlName]=\"control?.name\"\n        ></lib-checkbox-input>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type === 'radio'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <input matInput [formControlName]=\"control?.name\" hidden />\n        <lib-radio-input\n          [radioControl]=\"control\"\n          [formControlName]=\"control?.name\"\n        ></lib-radio-input>\n      </mat-form-field>\n\n      <mat-form-field *ngIf=\"control?.type == 'toggle'\" floatLabel=\"always\">\n        <mat-label>{{ control?.label }}</mat-label>\n        <mat-slide-toggle\n          [formControlName]=\"control?.name\"\n          [checked]=\"control?.value\"\n          [required]=\"control?.validators?.required\"\n          style=\"margin-top: 10px\"\n        >\n        </mat-slide-toggle>\n        <textarea\n          matInput\n          [formControlName]=\"control?.name\"\n          hidden\n          [required]=\"control?.validators?.required\"\n        ></textarea>\n      </mat-form-field>\n\n      <mat-error\n        *ngIf=\"\n          myForm.get(control?.name)?.touched &&\n          myForm.get(control?.name)?.invalid\n        \"\n      >\n        <div\n          class=\"error-message\"\n          *ngIf=\"\n            control?.errorMessage[\n              ((myForm.get(control.name)?.errors | keyvalue) || [])[0].key\n            ];\n            else genericErrorMessage\n          \"\n        >\n          <mat-icon class=\"error-icon\" matPrefix>error_outline</mat-icon>\n          {{\n            control?.errorMessage[\n              ((myForm.get(control.name)?.errors | keyvalue) || [])[0].key\n            ]\n          }}\n        </div>\n        <ng-template #genericErrorMessage>\n          <div class=\"error-message\">\n            <mat-icon class=\"error-icon\" matPrefix>error_outline</mat-icon>\n            Enter {{ control?.label }}\n          </div>\n        </ng-template>\n      </mat-error>\n    </div>\n  </form>\n</div>\n", styles: ["mat-form-field{width:100%}.error-message{display:flex;flex-direction:row;font-size:12px;margin-top:-10px}.error-icon{font-size:16px;width:20px;height:auto}::ng-deep .mat-form-field-appearance-fill .mat-form-field-flex{background-color:#fff}mat-label{font-size:20px;margin-bottom:10px}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f;background-color:#fff;color:#000000de}.mat-calendar-body-selected{background-color:#007f51;color:#fff}.mat-calendar-body-cell-content{border:none!important}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:#fff!important}.mdc-text-field--filled{background-color:#fff!important}\n"] }]
        }], ctorParameters: () => [{ type: i1.FormBuilder }], propDecorators: { formJson: [{
                type: Input
            }], picker: [{
                type: ViewChild,
                args: ['picker']
            }] } });

// import {
//   NgxMatDatetimePickerModule,
//   NgxMatTimepickerModule,
// } from '@angular-material-components/datetime-picker';
// import { NgxMatMomentModule } from '@angular-material-components/moment-adapter';
class DynamicFormModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DynamicFormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.8", ngImport: i0, type: DynamicFormModule, declarations: [DynamicFormComponent,
            MainFormComponent,
            ChipInputComponent,
            DialogInputComponent,
            RadioInputComponent,
            CheckboxInputComponent,
            StarRatingComponent], imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            // BrowserAnimationsModule,
            MatInputModule,
            MatButtonModule,
            MatFormFieldModule,
            MatIconModule,
            MatSelectModule,
            MatChipsModule,
            MatSlideToggleModule,
            MatDialogModule,
            MatSliderModule,
            MatCheckboxModule,
            MatRadioModule,
            MatDatepickerModule], exports: [MainFormComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DynamicFormModule, imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            // BrowserAnimationsModule,
            MatInputModule,
            MatButtonModule,
            MatFormFieldModule,
            MatIconModule,
            MatSelectModule,
            MatChipsModule,
            MatSlideToggleModule,
            MatDialogModule,
            MatSliderModule,
            MatCheckboxModule,
            MatRadioModule,
            MatDatepickerModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DynamicFormModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        DynamicFormComponent,
                        MainFormComponent,
                        ChipInputComponent,
                        DialogInputComponent,
                        RadioInputComponent,
                        CheckboxInputComponent,
                        StarRatingComponent,
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        // BrowserAnimationsModule,
                        MatInputModule,
                        MatButtonModule,
                        MatFormFieldModule,
                        MatIconModule,
                        MatSelectModule,
                        MatChipsModule,
                        MatSlideToggleModule,
                        MatDialogModule,
                        MatSliderModule,
                        MatCheckboxModule,
                        MatRadioModule,
                        MatDatepickerModule,
                        // NgxMatDatetimePickerModule,
                        // NgxMatTimepickerModule,
                        // NgxMatMomentModule,
                    ],
                    exports: [MainFormComponent],
                    schemas: [NO_ERRORS_SCHEMA]
                }]
        }] });

/*
 * Public API Surface of dynamic-form
 */
// export * from './lib/dynamic-form.service';

/**
 * Generated bundle index. Do not edit.
 */

export { DynamicFormComponent, DynamicFormModule, MainFormComponent };
//# sourceMappingURL=elevate-dynamic-form.mjs.map
